# Server-Side Rendering (SSR)

Liveflux supports rendering components on the server before the client runtime loads. SSR improves perceived performance, SEO, and accessibility while retaining interactive behavior once hydrated.

## Why Use SSR

- **Fast first paint**: Serve fully rendered HTML without waiting for client JavaScript.
- **SEO**: Search engines receive meaningful markup instead of placeholders.
- **Progressive enhancement**: Users without JavaScript still see the initial state.

## APIs

Located in `ssr.go`:

- `liveflux.SSR(c ComponentInterface, params ...map[string]string) hb.TagInterface`
- `liveflux.SSRHTML(c ComponentInterface, params ...map[string]string) string`

Both functions:

1. Ensure the component has an alias (`SetAlias`) and ID (`SetID` when missing).
2. Call `Mount` with provided params.
3. Store the component in `StoreDefault` so subsequent client actions reuse the state.
4. Return rendered markup (`hb.TagInterface` or string).

## Basic Usage

```go
inst, err := liveflux.New(&counter.Component{})
if err != nil {
    // handle error
}
html := liveflux.SSRHTML(inst, map[string]string{"userID": "42"})
fmt.Fprintf(w, "<div class=\"counter\">%s</div>", html)
fmt.Fprintf(w, "%s", liveflux.Script())
```

- `liveflux.New` clones a registered component prototype.
- Params map to `Mount` args just like placeholders.
- Always include `liveflux.Script()` so the client can hydrate and handle actions.

## Hydration Flow

1. Server responds with SSR markup.
2. Client script scans for `data-flux-root="1"` nodes (generated by `Base.Root`).
3. Client reads hidden inputs (`liveflux_component_alias`, `liveflux_component_id`) and keeps the SSR DOM as-is.
4. Actions (form submissions/WebSockets) reuse the existing component ID, preserving state on the server.

## Mixed SSR and Placeholders

You can combine SSR and client-side mounting on the same page:

```go
page := hb.Div().
    Child(liveflux.SSR(userProfile)).
    Child(liveflux.PlaceholderByAlias("notifications"))
```

`userProfile` renders immediately; `notifications` mounts asynchronously.

## Error Handling

If `Mount` returns an error, `SSR` renders an alert element with the error message. Customize this behavior by wrapping SSR calls and handling errors yourself.

```go
tag := liveflux.SSR(component)
if div, ok := tag.(interface{ InnerHTML() string }); ok {
    // inspect for error messages or custom classes
}
```

## Custom Store Considerations

SSR uses `StoreDefault` directly. When supplying a custom store to your HTTP/WebSocket handlers, ensure SSR also writes to the same backend. Options:

- Override `StoreDefault` before calling `SSR`:

```go
liveflux.StoreDefault = mySharedStore
```

- Call your store explicitly after SSR to persist state in another backend.

## Caching and Reuse

For highly dynamic pages, SSR caches may speed up rendering. Cache the HTML returned by `SSRHTML` alongside component IDs. Ensure cached IDs remain unique or regenerate components per request to avoid state leakage.

## Testing SSR

Use the helpers in `ssr_test.go` as examples for verifying HTML output and ensuring state is stored. Assertions typically check that the rendered HTML contains the expected hidden inputs and content.
